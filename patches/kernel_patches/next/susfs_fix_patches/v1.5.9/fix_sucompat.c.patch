diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index c1e803d7..1e8f98e6 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -12,10 +12,13 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
 #include <linux/sched/task_stack.h>
 #else
 #include <linux/sched.h>
 #endif
+#ifdef CONFIG_KSU_SUSFS_SUS_SU
+#include <linux/susfs_def.h>
+#endif
 
 #include "objsec.h"
 #include "arch.h"
 #include "allowlist.h"
 #include "klog.h" // IWYU pragma: keep
@@ -42,21 +45,17 @@
 	char __user *p = (void __user *)current_user_stack_pointer() - len;
 
 	return copy_to_user(p, d, len) ? NULL : p;
 }
 
-static char __user *sh_user_path(void)
+static inline char __user *sh_user_path(void)
 {
-	static const char sh_path[] = "/system/bin/sh";
-
 	return userspace_stack_buffer(sh_path, sizeof(sh_path));
 }
 
-static char __user *ksud_user_path(void)
+static inline char __user *ksud_user_path(void)
 {
-	static const char ksud_path[] = KSUD_PATH;
-
 	return userspace_stack_buffer(ksud_path, sizeof(ksud_path));
 }
 
 // every little bit helps here
 __attribute__((hot, no_stack_protector))
@@ -83,11 +82,9 @@
 				const char *syscall_name,
 				const bool escalate)
 {
-	const char su[] = SU_PATH;
-
-	char path[sizeof(su) + 1]; // sizeof includes nullterm already!
+	char path[sizeof(su) + 1] = {0};
 	long len = ksu_strncpy_from_user_retry(path, *filename_user, sizeof(path));
 	if (len <= 0) // sizeof(su) is not zero
 		return 0;
 
 	path[sizeof(path) - 1] = '\0';
@@ -116,28 +115,51 @@
 	if (!ksu_sucompat_non_kp) {
 		return 0;
 	}
 #endif
 
+#ifndef CONFIG_KSU_SUSFS_SUS_SU
 	if (!is_su_allowed((const void *)filename_user))
 		return 0;
+#endif
 
 	return ksu_sucompat_user_common(filename_user, "faccessat", false);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(CONFIG_KSU_SUSFS_SUS_SU)
+struct filename* susfs_ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags) {
+	struct filename *name = getname_flags(*filename_user, getname_statx_lookup_flags(*flags), NULL);
+
+	if (unlikely(IS_ERR(name) || name->name == NULL)) {
+		return name;
+	}
+
+	if (likely(memcmp(name->name, su, sizeof(su)))) {
+		return name;
+	}
+
+	const char sh[] = SH_PATH;
+	pr_info("vfs_fstatat su->sh!\n");
+	memcpy((void *)name->name, sh, sizeof(sh));
+	return name;
+}
+#endif
+
 // sys_newfstatat, sys_fstat64
 int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
 {
 
 #ifndef CONFIG_KSU_KPROBES_HOOK
 	if (!ksu_sucompat_non_kp) {
 		return 0;
 	}
 #endif
 
+#ifndef CONFIG_KSU_SUSFS_SUS_SU
 	if (!is_su_allowed((const void *)filename_user))
 		return 0;
+#endif
 
 	return ksu_sucompat_user_common(filename_user, "newfstatat", false);
 }
 
 // sys_execve, compat_sys_execve
@@ -169,23 +191,25 @@
 	if (!ksu_sucompat_non_kp) {
 		return 0;
 	}
 #endif
 
+#ifndef CONFIG_KSU_SUSFS_SUS_SU
 	if (!is_su_allowed((const void *)filename_ptr))
 		return 0;
+#endif
 
 	filename = *filename_ptr;
 	if (IS_ERR(filename)) {
 		return 0;
 	}
 
 	if (likely(memcmp(filename->name, su, sizeof(su))))
 		return 0;
 
 	pr_info("do_execveat_common su found\n");
-	memcpy((void *)filename->name, sh, sizeof(sh));
+	memcpy((void *)filename->name, ksud_path, sizeof(ksud_path));
 
 	escape_to_root();
 
 	return 0;
 }
