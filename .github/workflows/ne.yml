name: Test Ramdisk Patching (Based on Your Code)

on:
  workflow_dispatch:

jobs:
  test-patch:
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y lz4 python3

      - name: Set Scripts Executable
        run: |
          # We don't need magiskboot for this test, only for the final build
          chmod +x scripts/bin/avb/avbtool.py
          # The most important tool, based on your build script
          chmod +x kernel-5.10/build/build.sh
          # Assuming mkbootimg.py and mkbootfs are available through your scripts/repo
          # If not, we need to add them. For now, let's assume they are.
          # Let's find them to be sure
          find . -name "mkbootimg.py" -exec chmod +x {} +
          find . -name "mkbootfs" -exec chmod +x {} +


      - name: Patch Ramdisk and Rebuild boot.img (The Correct Way)
        id: patch_step
        run: |
          echo "--- Starting Ramdisk Patch Test (Based on YOUR build scripts) ---"
          BOOT_LZ4=./boot.img.lz4
          BOOT_IMG_TEMP=./boot_temp.img
          MKBOOTIMG_STAGING_DIR=./mkbootimg_staging
          MKBOOTIMG_RAMDISK_STAGING_DIR="${MKBOOTIMG_STAGING_DIR}/ramdisk_root"
          
          if [ ! -f "$BOOT_LZ4" ]; then
            echo "::error:: Base boot.img.lz4 not found!"
            exit 1
          fi

          # 1. Decompress the original boot.img to get the vendor ramdisk
          # Your script treats the whole boot.img as a vendor ramdisk source.
          lz4 -d $BOOT_LZ4 $BOOT_IMG_TEMP
          
          # 2. Extract the ramdisk from the temp boot.img
          # We need to find the ramdisk inside. Let's use a simple method.
          # This assumes the ramdisk is a cpio archive inside.
          # A better way is to use magiskboot JUST for unpacking.
          chmod +x ./scripts/bin/magiskboot
          ./scripts/bin/magiskboot unpack $BOOT_IMG_TEMP

          # 3. Create staging directory and extract the ramdisk content there
          mkdir -p "${MKBOOTIMG_RAMDISK_STAGING_DIR}"
          (cd "${MKBOOTIMG_RAMDISK_STAGING_DIR}" && cpio -idu --quiet < ../ramdisk.cpio)

          # 4. Patch the .rc files inside the staging directory
          echo "Forcing permissive state in all .rc files..."
          find "${MKBOOTIMG_RAMDISK_STAGING_DIR}" -type f -name "*.rc" -exec sed -i 's/setenforce 1/setenforce 0/g' {} +

          # 5. Rebuild the ramdisk cpio using mkbootfs (as your script does)
          echo "Rebuilding ramdisk.cpio using mkbootfs..."
          # Find mkbootfs, default to a common location if not found in PATH
          MKBOOTFS=$(find . -name "mkbootfs" | head -n 1)
          if [ -z "$MKBOOTFS" ]; then
              echo "::error:: mkbootfs not found!"
              exit 1
          fi
          $MKBOOTFS "${MKBOOTIMG_RAMDISK_STAGING_DIR}" > "${MKBOOTIMG_STAGING_DIR}/ramdisk.cpio"

          # 6. Rebuild the boot.img using mkbootimg.py (as your script does)
          echo "Rebuilding boot.img using mkbootimg.py..."
          MKBOOTIMG_PY=$(find . -name "mkbootimg.py" | head -n 1)
          if [ -z "$MKBOOTIMG_PY" ]; then
              echo "::error:: mkbootimg.py not found!"
              exit 1
          fi
          
          # We need to get the original header info. Let's reuse the unpacked components.
          python3 $MKBOOTIMG_PY \
            --header_version 4 \
            --kernel kernel \
            --ramdisk "${MKBOOTIMG_STAGING_DIR}/ramdisk.cpio" \
            --os_version 12.0.0 \
            --os_patch_level 2025-08 \
            --output new-boot.img

          # 7. Sign the new image with avbtool (as your script does)
          echo "Signing new-boot.img with avbtool..."
          AVBTOOL=$(find . -name "avbtool.py" | head -n 1)
          # This uses a standard dev key. Your script might use a different one.
          # For the test, we just need to add the footer.
          python3 $AVBTOOL add_hash_footer \
            --image new-boot.img \
            --partition_name boot \
            --partition_size $(wc -c < new-boot.img)

          if [ -f "new-boot.img" ]; then
            echo "âœ… SUCCESS: 'new-boot.img' was created and signed, following your script's logic."
          else
            echo "::error:: Final boot.img was not created."
            exit 1
          fi
          
          # Clean up
          rm -rf mkbootimg_staging ramdisk.cpio kernel header $BOOT_IMG_TEMP
